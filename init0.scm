(define scheme-implementation-type (lambda () 'TSCHEME))
(define scheme-implementation-version (lambda () "Jun. 20, 1998"))
(define caar (lambda (x) (car (car x))))
(define cadr (lambda (x) (car (cdr x))))
(define cdar (lambda (x) (cdr (car x))))
(define cddr (lambda (x) (cdr (cdr x))))
(define caaar (lambda (x) (car (caar x))))
(define caadr (lambda (x) (car (cadr x))))
(define cadar (lambda (x) (car (cdar x))))
(define caddr (lambda (x) (car (cddr x))))
(define cdaar (lambda (x) (cdr (caar x))))
(define cdadr (lambda (x) (cdr (cadr x))))
(define cddar (lambda (x) (cdr (cdar x))))
(define cdddr (lambda (x) (cdr (cddr x))))
(define caaaar (lambda (x) (car (caaar x))))
(define caaadr (lambda (x) (car (caadr x))))
(define caadar (lambda (x) (car (cadar x))))
(define caaddr (lambda (x) (car (caddr x))))
(define cadaar (lambda (x) (car (cdaar x))))
(define cadadr (lambda (x) (car (cdadr x))))
(define caddar (lambda (x) (car (cddar x))))
(define cadddr (lambda (x) (car (cdddr x))))
(define cdaaar (lambda (x) (cdr (caaar x))))
(define cdaadr (lambda (x) (cdr (caadr x))))
(define cdadar (lambda (x) (cdr (cadar x))))
(define cdaddr (lambda (x) (cdr (caddr x))))
(define cddaar (lambda (x) (cdr (cdaar x))))
(define cddadr (lambda (x) (cdr (cdadr x))))
(define cdddar (lambda (x) (cdr (cddar x))))
(define cddddr (lambda (x) (cdr (cdddr x))))
(define first car)
(define second cadr)
(define third caddr)
(define fourth cadddr)
(define fifth (lambda (x) (car (cddddr x))))
(define sixth (lambda (x) (cadr (cddddr x))))
(define seventh (lambda (x) (caddr (cddddr x))))
(define eighth (lambda (x) (cadddr (cddddr x))))
(define nth (lambda (l n) (if (pair? l) (if (< n 1) (car l) (nth (cdr l) (|-1+| n))) (error "nth: invalid argument"))))
(define equal? (lambda (x y) (cond ((eq? x y)) ((and (pair? x) (pair? y) (equal? (car x) (car y)) (equal? (cdr x) (cdr y)))) (else #f))))
(define assoc (lambda (key alist) (cond ((null? alist) #f) ((eq? key (caar alist)) (car alist)) (else (assoc key (cdr alist))))))
(define vector? (lambda (x) #f))
(define atom? (lambda (x) (not (pair? x))))
(define append (lambda args (letrec ((append2 (lambda (xs ys) (if (null? xs) ys (cons (car xs) (append2 (cdr xs) ys)))))) (letrec ((loop (lambda (args) (if (null? args) '() (append2 (car args) (loop (cdr args))))))) (loop args)))))
(define reverse (lambda (l) (letrec ((rev1 (lambda (l a) (if (null? l) a (rev1 (cdr l) (cons (car l) a)))))) (rev1 l '()))))
(define list* (lambda args (if (null? args) '() (append (butlast args) (last args)))))
(define butlast (lambda (l) (cond ((null? l) (error "butlast")) ((null? (cdr l)) '()) (else (cons (car l) (butlast (cdr l)))))))
(define last (lambda (l) (cond ((null? l) (error "last")) ((null? (cdr l)) (car l)) (else (last (cdr l))))))
(define map1 (lambda (f xs) (if (null? xs) '() (cons (f (car xs)) (map1 f (cdr xs))))))
(define map (lambda (f . args) (if (null? (car args)) '() (let ((args1 (map1 car args)) (argsr (map1 cdr args))) (cons (apply f args1) (apply map f argsr))))))
(define expand-quasiquote (lambda (e) (cond ((and (atom? e) (not (symbol? e))) e) ((symbol? e) (list 'quote e)) (else (letrec ((loop (lambda (l a b) (cond ((null? l) (cons 'append (reverse (cons (cons 'list (reverse b)) a)))) (else (if (pair? (car l)) (case (caar l) ((unquote) (loop (cdr l) a (cons (cadar l) b))) ((unquote-splicing) (loop (cdr l) (cons (cadar l) (cons (cons 'list (reverse b)) a)) '())) (else (loop (cdr l) a (cons (expand-quasiquote (car l)) b)))) (loop (cdr l) a (cons (expand-quasiquote (car l)) b)))))))) (loop e '() '()))))))
(define call-with-input-file (lambda (infile f) (let ((inport (open-input-file infile))) (f inport) (close-input-port inport))))
(define call-with-output-file (lambda (outfile f) (let ((outport (open-output-file outfile))) (f outport) (close-output-port outport))))
(define gentemp (let ((*gentemp-counter* 0)) (lambda () (let ((s (string->symbol (string-append "SCM:" (number->string *gentemp-counter*))))) (set! *gentemp-counter* (+ *gentemp-counter* 1)) s))))
(define *prompt* "TSCHEME> ")
(define *default-prompt* "--> ")
(define sys:prompt-and-read (lambda args (display (if (null? args) *default-prompt* (car args))) (read)))
(define sys:toplevel (lambda () (display *prompt*) (let ((input (read))) (cond ((or (eof-object? input) (eq? input 'bye)) (display "Bye!") (newline)) (else (write (sys:eval (sys:simplify input) '())) (newline) (sys:toplevel))))))
(define load (lambda (file) (call-with-input-file file (lambda (inport) (display "Loading ") (write file) (display " ... ") (letrec ((loop (lambda (e) (if (eof-object? e) (begin (display "done.") (newline)) (begin (sys:eval (sys:simplify e) '()) (loop (read inport))))))) (loop (read inport)))))))
(define eval (lambda (x) (sys:eval (sys:simplify x) '())))
(define map1 (lambda (f xs) (if (null? xs) '() (cons (f (car xs)) (map1 f (cdr xs))))))
(define list* (lambda args (if (null? args) '() (append (butlast args) (last args)))))
(define butlast (lambda (l) (cond ((null? l) (error "butlast")) ((null? (cdr l)) '()) (else (cons (car l) (butlast (cdr l)))))))
(define last (lambda (l) (cond ((null? l) (error "last")) ((null? (cdr l)) (car l)) (else (last (cdr l))))))
(define sys:simplify (lambda (exp) (cond ((boolean? exp) exp) ((number? exp) exp) ((char? exp) exp) ((string? exp) exp) ((symbol? exp) exp) ((pair? exp) (let ((op (car exp)) (args (cdr exp))) (cond ((eq? op 'quote) exp) ((eq? op 'lambda) (list* 'lambda (car args) (sys:simplify-body (cdr args)))) ((eq? op 'let) (if (symbol? (car args)) (list 'letrec (list (list (car args) (list* 'lambda (sys:let-vars (cadr args)) (sys:simplify-body (cddr args))))) (list* (car args) (map1 sys:simplify (sys:let-exps (cadr args))))) (list* 'let (sys:simplify-let-bspecs (car args)) (sys:simplify-body (cdr args))))) ((eq? op 'let*) (sys:simplify-let* (car args) (cdr args))) ((eq? op 'letrec) (list* 'letrec (sys:simplify-let-bspecs (car args)) (sys:simplify-body (cdr args)))) ((eq? op 'if) (list* 'if (map1 sys:simplify args))) ((eq? op 'cond) (list* 'cond (map1 (lambda (clause) (list* (if (eq? (car clause) 'else) 'else (sys:simplify (car clause))) (map1 sys:simplify (cdr clause)))) args))) ((eq? op 'case) (list* 'case (sys:simplify (car args)) (map1 (lambda (clause) (list* (car clause) (map1 sys:simplify (cdr clause)))) (cdr args)))) ((eq? op 'and) (list* 'and (map1 sys:simplify args))) ((eq? op 'or) (list* 'or (map1 sys:simplify args))) ((eq? op 'do)) ((eq? op 'begin) (list* 'begin (sys:simplify-body args))) ((eq? op 'set!) (list 'set! (car args) (sys:simplify (cadr args)))) ((eq? op 'define) (if (pair? (car args)) (list 'define (caar args) (list* 'lambda (cdar args) (sys:simplify-body (cdr args)))) (list 'define (car args) (sys:simplify (cadr args))))) ((eq? op 'quasiquote) (sys:expand-quasiquote (car args))) (else (map1 sys:simplify exp))))) (else (error "Unknown expression type.")))))
(define sys:simplify-let-bspecs (lambda (bspecs) (map1 (lambda (bspec) (list (car bspec) (sys:simplify (cadr bspec)))) bspecs)))
(define sys:let-vars (lambda (bspecs) (map1 car bspecs)))
(define sys:let-exps (lambda (bspecs) (map1 cadr bspecs)))
(define sys:simplify-let* (lambda (bspecs body) (if (null? bspecs) (sys:simplify-body body) (list* 'let (list (list (caar bspecs) (sys:simplify (cadar bspecs)))) (if (null? (cdr bspecs)) (sys:simplify-body body) (list (sys:simplify-let* (cdr bspecs) body)))))))
(define sys:simplify-body (lambda (body) (letrec ((sys:simplify-body-define (lambda (body bspecs) (cond ((null? body) '()) ((and (list? (car body)) (not (null? (car body))) (eq? (car (car body)) 'define)) (let ((var (if (pair? (cadr (car body))) (caadr (car body)) (cadr (car body)))) (exp (if (pair? (cadr (car body))) (list* 'lambda (cdadr (car body)) (sys:simplify-body (cddr (car body)))) (sys:simplify (caddr (car body)))))) (sys:simplify-body-define (cdr body) (cons (list var exp) bspecs)))) (else (if (null? bspecs) (sys:simplify-body-others body) (list (list* 'letrec (reverse bspecs) (sys:simplify-body-others body)))))))) (sys:simplify-body-others (lambda (body) (cond ((null? body) '()) ((and (list? (car body)) (not (null? (car body))) (eq? (car (car body)) 'define)) (error "Invalid local define.")) (else (cons (sys:simplify (car body)) (sys:simplify-body-others (cdr body)))))))) (sys:simplify-body-define body '()))))
(define sys:expand-quasiquote (lambda (e) (cond ((and (atom? e) (not (symbol? e))) e) ((symbol? e) (list 'quote e)) (else (letrec ((loop (lambda (l a b) (cond ((null? l) (cons 'append (reverse (cons (cons 'list (reverse b)) a)))) (else (if (pair? (car l)) (case (caar l) ((unquote) (loop (cdr l) a (cons (cadar l) b))) ((unquote-splicing) (loop (cdr l) (cons (cadar l) (cons (cons 'list (reverse b)) a)) '())) (else (loop (cdr l) a (cons (sys:expand-quasiquote (car l)) b)))) (loop (cdr l) a (cons (sys:expand-quasiquote (car l)) b)))))))) (loop e '() '()))))))
(define sys:simplify-all (lambda (inport outport) (letrec ((loop (lambda (e) (if (not (eof-object? e)) (begin (write (sys:simplify e) outport) (newline outport) (loop (read inport))))))) (loop (read inport)))))
(define sys:simplify-file (lambda (infile outfile) (call-with-input-file infile (lambda (inport) (call-with-output-file outfile (lambda (outport) (sys:simplify-all inport outport)))))))
(define sys:make-init (lambda (outfile) (display "Making ") (display outfile) (newline) (call-with-output-file outfile (lambda (outport) (call-with-input-file "init-src.scm" (lambda (inport) (sys:simplify-all inport outport))) (call-with-input-file "simplify.scm" (lambda (inport) (sys:simplify-all inport outport)))))))
